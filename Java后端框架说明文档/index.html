
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.5">
    
    
      
        <title>后端框架说明文档 - 移动软件开发作业指南</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.558e4712.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.2505c338.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="移动软件开发作业指南" class="md-header__button md-logo" aria-label="移动软件开发作业指南" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            移动软件开发作业指南
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              后端框架说明文档
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="移动软件开发作业指南" class="md-nav__button md-logo" aria-label="移动软件开发作业指南" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    移动软件开发作业指南
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../week1_java%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="md-nav__link">
        任务1：Java环境搭建
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AF%BE%E7%A8%8B%E5%9B%9E%E9%A1%BE%E5%8F%8A%E6%84%9F%E6%83%B3/" class="md-nav__link">
        关于课程的回顾和一些感想
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    一、后端依赖
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    二、后端框架解析
  </a>
  
    <nav class="md-nav" aria-label="二、后端框架解析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 目录介绍
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 框架结构分析
  </a>
  
    <nav class="md-nav" aria-label="2.2 框架结构分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221-base" class="md-nav__link">
    2.2.1 Base基础模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222-frame" class="md-nav__link">
    2.2.2 Frame框架模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223-biz" class="md-nav__link">
    2.2.3 Biz业务模块
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    2.3 框架特性介绍
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    三、后端编程规范
  </a>
  
    <nav class="md-nav" aria-label="三、后端编程规范">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    3.1 业务逻辑规范
  </a>
  
    <nav class="md-nav" aria-label="3.1 业务逻辑规范">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#311" class="md-nav__link">
    3.1.1 不可违背的业务逻辑规范
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#322" class="md-nav__link">
    3.2.2 推荐性的业务逻辑规范
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    3.2 代码书写规范
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="_1">后端框架说明文档</h1>
<p>为了帮助同学们进行大作业的后端框架，同学们可以<a href="https://cloud.tsinghua.edu.cn/f/94b286afcf8d4bbf963b/?dl=1">点击链接下载</a></p>
<h2 id="_2">一、后端依赖</h2>
<p>​       本课程的后端框架由助教搭建，为了完美运行后端框架，同学们需要安装的依赖如下：</p>
<ul>
<li><strong>Java</strong>：需要的Java版本为<strong>1.8</strong>以上，框架中使用到了Java的<strong>反射机制</strong>、<strong>注解</strong>等特性，需要同学们自行学习相关内容。</li>
<li><strong>Maven</strong>：一个<strong>项目管理工具</strong>，是 Apache 下的一个纯 Java 开发的开源项目。用于管理项目的构建、生成文档、解析依赖、发布等过程。你可以使用Maven快速地引入别人开发好的Java包、自动生成Java文档、快速构建及发布Java项目。想了解更多细节请查看<a href="http://maven.apache.org/index.html">官方文档</a>。</li>
<li><strong>SpringBoot</strong>：一个<strong>Java后台框架</strong>，可以简化<strong>Spring</strong>应用的搭建以及开发过程，是当前最流行的Java后端框架之一，请同学们自学<strong>Spring</strong>相关知识，主要关注<strong>AOP（面向切面编程）</strong>概念即可。</li>
<li><strong>MongoDB</strong>：一个<strong>非关系型数据库</strong>，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB数据库按照JSON格式存储单个对象，这意味着MongoDB可以存储复杂的数据类型（如数组、字典等）。关系型数据库数据关联性强，存储格式限制性大，以致于经常需要连表查询，出现冗长的SQL语句，MongoDB通过JSON格式的存储很好地避免了这一点。同时在正常情况下MongoDB不再支持事务机制，拥有比关系型数据库更高的并发，但是MongoDB提供了一系列原子性操作，保证了数据的完整性。MongoDB是当前使用最广的<strong>非关系型数据库</strong>。想了解更多细节可以查看<a href="https://docs.mongoing.com/">MongoDB相关文档</a>，MongoDB集合在Spring中的api文档请<a href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoTemplate.html">点击此处</a>。</li>
<li><strong>Redis</strong>：一个<strong>Key-Value</strong>存储式<strong>内存数据库</strong>，其有几大特点：①全部数据存储在内存之中，避免了磁盘操作带来的瓶颈，拥有极快的访问速度；②采用<strong>Key-Value</strong>形式存储内容，使用哈希进行索引，理论上的查询时间复杂度为O(1)级别，可以看做一个加强版的HashMap；③采用单线程处理业务逻辑（利用了I/O多路复用原则，解析请求是多线程的），保证了两个业务逻辑一定有先后顺序，不可能同时执行，不需要考虑竞争的问题。由于以上原则，Redis数据库的并发很高，比普通的硬盘数据库普遍快5倍以上，Redis数据库一般用于缓存，提高高并发下的系统运行效率。想了解更多细节可以查看<a href="http://www.redis.cn/documentation.html">Redis官方文档</a>，同时可以参考<a href="http://redisdoc.com/">Redis指令API文档</a>。</li>
<li><strong>Nginx</strong>：一个高性能的HTTP和反向代理服务器，在本项目中主要使用到其<strong>端口转发</strong>和<strong>静态文件代理</strong>的功能。有<a href="https://www.nginx.cn/doc/">Nginx文档</a>可供大家参考。</li>
<li>&lt;!--</li>
<li><strong>Docker</strong>（<font color="red" size=2>唯一需要同学自己安装的依赖</font>）：一个<strong>轻量级的虚拟化容器</strong>。Docker可以在所有系统上安装，是一个轻量级的虚拟机，用户可以在Docker容器中运行一个独立于电脑主机的新系统，然后在系统上安装依赖、修改文件等。同时容器还可以打包导出为镜像，方便他人或自己在其它电脑上导入。其作用类似于Java虚拟机，即屏蔽不同系统的底层细节，为在其中运行的程序提供统一的接口。不同的是Java虚拟机上只能运行Java程序，而Docker容器上运行的则是一个虚拟机系统，用户可以随意迁移虚拟机系统而不会报错。实现了一次配置，多次利用的功能。了解更多请参考<a href="http://www.dockerinfo.net/document">Docker文档</a>，安装Docker和使用可以查看<a href="https://www.runoob.com/docker/docker-tutorial.html">Docker教程</a>。<font color="red">助教已经将后端框架所需要的全部依赖都封装于Docker容器中，同学们只需要安装好Docker然后导入Course.tar镜像文件就可以直接运行后端框架了，具体操作过程请参考第四章！</font></li>
<li>--&gt;</li>
</ul>
<p>​       以上相关内容请同学们自学为主，课堂上不会展开详细的介绍，同学们可以先掌握一个基本，主要是多实战。实战多了，坑踩多了，很多东西理解就深入了。</p>
<h2 id="_3">二、后端框架解析</h2>
<h3 id="21">2.1 目录介绍</h3>
<p>​       使用<strong>IntelliJ IDEA</strong>打开项目文件，可以观察到的项目目录如下：</p>
<p><img src="../img/pictures/框架目录.png" /></p>
<p>​       其中</p>
<ul>
<li><strong>.idea</strong>文件夹：IDEA的配置文件夹，不需要修改，忽略。</li>
<li><strong>.mvn</strong>文件夹：Maven的配置文件夹，不需要修改，忽略。</li>
<li><strong>logs</strong>文件夹：项目配置的日志输出目录，存储着服务器的<strong>运行日志</strong>，你可以在项目设置中修改为其它的路径。</li>
<li><strong>src</strong>文件夹：项目的Java源码和资源文件所在文件夹。</li>
<li><strong>pom.xml</strong>：Maven的配置文件，如果需要修改外部依赖，则需要修改此文件。</li>
<li>其它文件：都是默认的配置文件，不需要修改，忽略。</li>
</ul>
<p>​       <strong>src</strong>文件夹中存储着项目的主体：</p>
<p><img alt="" src="../img/pictures/src目录.png" /></p>
<ul>
<li>
<p><strong>test</strong>⽂件夹：存储着测试相关代码，测试的时候才有⽤，实际开发中不需要关注  </p>
</li>
<li>
<p><strong>main.java</strong>文件夹：存储项目的Java源码，都在<strong>com.flying.dragon</strong>包中。</p>
</li>
<li><strong>main.resources</strong>文件夹：存储着项目的资源文件，其中<strong>application.properties</strong>为SpringBoot配置文件，<strong>logback.xml</strong>为日志配置文件。static和templates在开发静态⽹站时⽤到，主要⽤于托管静态⽂件。  </li>
</ul>
<h3 id="22">2.2 框架结构分析</h3>
<p><img alt="" src="../img/pictures/三大模块.png" /></p>
<p>​       如图，项目的主要代码由三大模块组成（<strong>DragonApplication</strong>是<strong>SpringBoot</strong>设置的默认的启动类，只负责启动应用，没有什么内部逻辑，不包含在模块中）：①<strong>Base基础模块</strong>；②<strong>Biz业务模块</strong>；③<strong>Frame框架模块</strong>。</p>
<p><img src="../img/pictures/截屏2021-02-06 11.02.05.png" style="zoom:50%;" /></p>
<p>​       如图为三大模块之间的相互关系，下面将对这三大模块展开详细的介绍。</p>
<h4 id="221-base">2.2.1 Base基础模块</h4>
<p><img alt="" src="../img/pictures/base模块.png" /></p>
<p>​       <strong>Base基础模块</strong>主要是为项目提供基础属性，如</p>
<ul>
<li>
<p><strong>Annotation注解</strong>：项目的所有Java注解。</p>
</li>
<li>
<p><strong>Constant常量</strong>：项目的所有常量。</p>
</li>
<li>
<p><strong>Enum枚举</strong>：项目中的所有枚举，报错、警告和业务枚举不在此中。</p>
</li>
<li>
<p><strong>Error错误</strong>：项目中所有的报错，包括警告和错误的枚举类。</p>
</li>
<li>
<p><strong>Model模型</strong>：项目中所有的模型，模型与数据库中的文档一一对应，当对象从数据库中读取出来会自动映射到对应的模型类中。</p>
</li>
</ul>
<p>值得一提的是，<strong>Base基础模块</strong>中都是<strong>静态数据</strong>，没有动态代码，<strong>Biz业务模块</strong>和<strong>Frame框架模块</strong>都可以利用到这些数据。</p>
<h4 id="222-frame">2.2.2 Frame框架模块</h4>
<p><img alt="" src="../img/pictures/frame模块.png" /></p>
<p>​       <strong>Frame框架模块</strong>搭建了项目的整体框架，并为<strong>Biz业务模块</strong>的业务运行提供了必需的工具，如：</p>
<ul>
<li><strong>Aspect</strong>切面：定义了项目中的所有切面（切面意义请自行学习<strong>Spring</strong>），切面可以控制业务的具体执行流程，如<strong>LogInAspect</strong>切面将判断用户是否登录和具有对应权限，有对应权限则执行对应业务，否则通过报错中断业务的执行。</li>
<li><strong>Config</strong>配置：定义了项目中的所有配置，这些配置是项目运行的基础，没有了这些配置，项目会运行不起来。<strong>WebSocketConfiguration</strong>配置了<strong>WebSocket</strong>监听端口，让后端可以处理<strong>WebSocket</strong>请求；而<strong>RedisConfig</strong>配置则配置了与<strong>Redis</strong>数据库的连接，让用户可以连接并处理<strong>Redis</strong>缓存。</li>
<li><strong>Util</strong>工具：定义了所有的工具类，这些类是被<strong>Biz业务模块</strong>广泛使用的，但又与业务逻辑无关的。这些工具类也都是助教以前在其它项目中使用过的。如<strong>RedisUtil</strong>工具类封装了对<strong>Redis</strong>数据库的便捷操作，封装的函数非常多，是以前的项目有这么多需求，所以写了这么多，这次只不过是复制粘贴过来了，所以里面的内容很全。相对于<strong>Biz业务模块</strong>与业务高度相关的代码，这部分的代码具有极强的可复用性，换言之，这些工具类换了一个项目也可以继续使用，不需要被替换。具体每个工具类的作用可以查看相关注解。</li>
</ul>
<h4 id="223-biz">2.2.3 Biz业务模块</h4>
<p><img alt="" src="../img/pictures/biz模块.png" /></p>
<p><strong>Biz业务模块</strong>是项目中最核心的部分，<strong>Base基础模块</strong>和<strong>Frame框架模块</strong>都是为<strong>Biz业务模块</strong>提供服务的，项目中所有的业务逻辑譬如用户登录、用户注册、注销登录等都在<strong>Biz业务模块</strong>中处理。业务模块有四⼤组件：
- <strong>Handler</strong>组件：处理所有的外部请求，对外部请求进⾏封装，然后转发到分发器<strong>Dispatcher</strong>中。
- <strong>Dispatcher</strong>组件：业务分发器，负责根据不同的业务参数输⼊，将不同的业务请求派发到对应的<strong>Controller</strong>处理逻辑之中。
- <strong>Controller</strong>组件：业务第⼀层处理组件，接受<strong>Dispatcher</strong>分发的业务并具体处理业务、返回处理结果。其中<strong>Params</strong>为业务的⼊参及出参，不与<strong>MongoDB</strong>数据库进⾏交互。
- <strong>Processor</strong>组件：业务第⼆层处理组件，负责执⾏<strong>原⼦逻辑</strong>，直接与<strong>MongoDB</strong>数据库进⾏交互，提供接⼝给第⼀层业务处理组件<strong>Controller</strong>层，具有⾼度的可复⽤性。如根据⽤户名获取⽤户、删除⼀个⽤户、增加⼀个⽤户，这些都是<strong>原⼦逻辑</strong>。  </p>
<p>​       外部请求统一由<strong>Handler</strong>接受，然后转发给<strong>Dispatcher</strong>，<strong>Dispatcher</strong>再派发给<strong>Controller</strong>，由<strong>Controller</strong>调用<strong>Processor</strong>接口完成业务逻辑处理，这四个部分的关系如下图所示：</p>
<p><img src="../img/pictures/处理示意图.png" style="zoom:100%;" /></p>
<p>​   外部的请求必须经过<strong>Handler</strong>然后封装为<strong>Controller.Params</strong>， <strong>Params</strong>如下图所示：    </p>
<p><img src="../img/pictures/Params.jpg" style="zoom:100%;" /></p>
<p>所有的参数类都继承⾃<strong>CommonParams</strong>类，此抽象类中封装了所有参数的通⽤操作。 <strong>CommonInParams</strong>和<strong>CommonOutParams</strong>直接继承⾃<strong>CommonParams</strong>类，是所有⼊参和出参的⽗类，所有⼊参和出参都必须是这两个类或者这两个类的⼦类。你可以针对不同的业务定制不同的⼊参或者出参，但是必须继承⾃此两类。<strong> CommonInParams</strong>是<strong>Controller</strong>层业务函数的参数， <strong>CommonOutParams</strong>是<strong>Controller</strong>层业务函数的返回值。
⼀个成功的业务<strong>Http</strong>请求（⽤户登录） 在<strong>Biz</strong>层中的处理逻辑如下图所示：</p>
<p><img src="../img/pictures/http请求.jpg" style="zoom:75%;" /></p>
<p>具体的处理细节可以查看相关源码加深理解。  </p>
<h3 id="23">2.3 框架特性介绍</h3>
<p>​       本框架内容追求<strong>高度模块化</strong>的原则，系统<strong>可扩展性极强</strong>，不管是小型系统开发还是大型系统开发都可以在此框架基础上拓展完成，是一个不错的Java服务器框架。在刚开始写代码的时候，同学们可能会感觉内部逻辑复杂，因为代码模块较多，新增一个业务可能需要修改多个模块。但是随着代码量的增加，业务的复杂程度不断上升，此框架良好的扩展性就会发挥作用，此框架可以保证大量的业务扩展而很难发生内部逻辑紊乱，这一点同学们可以在实际开发中慢慢体会。</p>
<p>​       此外，框架中封装了Quartz定时任务组件，同学们可以调用此组件完成服务器的定时任务。同时增加了<strong>Logback</strong>日志系统，方便同学追踪用户行为、定位服务器内部错误，日志的具体配置文件是<strong>resources/logback.xml</strong>。感兴趣的同学甚至还可以在日志系统的基础上配置日志监控，将日志内容图表化，可以更方便地统计自己的各业务执行状态，配置方式请自行搜索<strong>ELK(ElasticSearch + Kibana + Logstash)</strong>了解。</p>
<h2 id="_4">三、后端编程规范</h2>
<h3 id="31">3.1 业务逻辑规范</h3>
<p>​       业务逻辑规范分为<strong>不可违背</strong>和<strong>推荐性</strong>两大块，<strong>不可违背</strong>业务逻辑规范一旦被违背，则代码得分将大大降低，<strong>推荐性</strong>业务规范视完成程度酌情给分。</p>
<h4 id="311">3.1.1 不可违背的业务逻辑规范</h4>
<ol>
<li>所有外部请求必须经过<strong>Entrance</strong>处理，然后交由<strong>Dispatcher</strong>派发，才能转入内部执行，严禁任何外部请求绕过<strong>Entrance</strong>和<strong>Dispatcher</strong>转入内部执行，避免业务执行逻辑混乱。</li>
<li><strong>Dispatcher</strong>派发的请求只能派发给第一层业务处理逻辑<strong>Manager</strong>层执行，严禁将业务派发给第二层<strong>Processor</strong>层，避免业务派发逻辑混乱。</li>
<li>
<p><strong>Manager</strong>层<strong>业务执行函数</strong>的入参必须是<strong>CommonInParams</strong>或其子类，出参必须是<strong>CommonOutParams</strong>或其子类，这么做是为了规范业务入参和出参的格式，保证日后查看业务逻辑时不会出现出入参的紊乱。<strong>Processor</strong>层的出参和入参随意。</p>
</li>
<li>
<p><strong>Manager</strong>层可以调用<strong>Manager</strong>和<strong>Processor</strong>层的函数，<strong>Processor</strong>层只能调用<strong>Processor</strong>层的函数，严禁<strong>Processor</strong>层调用<strong>Manager</strong>层的函数，避免调用逻辑层级的混乱。</p>
</li>
<li>硬盘数据库(<strong>Mongodb</strong>)数据只能通过<strong>Processor</strong>层直接访问，严禁<strong>Manager</strong>层直接访问硬盘数据库，缓存数据库(<strong>Redis</strong>)随意，避免硬盘数据库操作逻辑混乱。</li>
<li>所有可能出现报错的业务逻辑都应该被<strong>try-catch</strong>包裹并处理，严禁出现任何不可能被捕获的异常，且必须记录异常日志，避免内部异常带来的业务逻辑混乱。同学们如果新增<strong>Entrance</strong>逻辑需要保证满足这一条原则。</li>
<li>所有的自定义报错均需列举在枚举类中（可参考<strong>SystemErrorEnum</strong>和<strong>UserWarnEnum</strong>示例），方便日后追溯根源。</li>
</ol>
<h4 id="322">3.2.2 推荐性的业务逻辑规范</h4>
<ol>
<li>执行关键操作时记录日志，方便根据日志追踪用户行为。</li>
<li>尽量将可复用的、需多次重复使用的、与业务无关的处理逻辑封装在<strong>Frame框架模块</strong>的<strong>Util工具包</strong>中，方便日后复用。</li>
</ol>
<h3 id="32">3.2 代码书写规范</h3>
<ol>
<li>代码应该书写工整，利用换行符、空格符保证代码的可读性，出现冗长的单行代码是较大的扣分项。</li>
<li>每个类、类中的每个字段和方法（除get和set方法）都需要有对应的注释说明，方法中如果代码量较多，也应该分块予以注释说明。</li>
<li>代码整体组织结构需要按照<strong>Base基础模块</strong>、<strong>Frame框架模块</strong>和<strong>Biz业务模块</strong>的三大模块原则来进行，且每个类应该按照相关性放在对应的包中。实际上框架已经帮大家分好模块和包了，基本上只需要在框架已有的包上进行扩展即可。</li>
</ol>
<!--

## 四、后端运行教程

​       由于**Mac**和**Windows**下的**Docker**实际运行在虚拟机上，而**Linux**下的**Docker**则直接运行在系统上，所以部分教程会因为系统的不同有所区别，没有写明不同系统的代表是所有系统通用的部分。

### 4.1 安装Docker

​       参考[Docker教程](https://www.runoob.com/docker/docker-tutorial.html)安装docker并配置好环境变量。

### 4.2 导入镜像

​       助教已经将所有的环境依赖直接封装在一个docker镜像文件course.tar中，请访问[链接](https://cloud.tsinghua.edu.cn/f/f2f5d3eebeb54b1d87cf/)下载镜像，同学们只需要运行如下命令导入该镜像即可：

<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>docker<span class="w"> </span>import<span class="w"> </span>course.tar<span class="w"> </span>course:v1
</code></pre></div>

​       然后运行```docker images```命令就可以看到导入的镜像文件。

### 4.3 创建Docker容器

####4.3.1 Mac和Windows系统

​       对于Mac和Window系统，运行如下命令以创建docker容器：

<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-itd<span class="w"> </span>-p<span class="w"> </span><span class="m">8070</span>-8090:8070-8090<span class="w"> </span>-p<span class="w"> </span><span class="m">6379</span>:6379<span class="w"> </span>-p<span class="w"> </span><span class="m">27017</span>:27017<span class="w"> </span>--name<span class="w"> </span>myWork<span class="w"> </span>course:v1<span class="w"> </span>bash
</code></pre></div>

​       其中```docker run```代表创建并运行容器，其它参数说明如下：

* ```-itd```：-i 交互式操作；-t 在终端运行命令；-d在后台运行。
* ```-p 8070-8090:8070-8090 -p 6379:6379 -p 27017:27017```：指定端口映射，将6378、27017和8070-8090的容器端口映射到主机端口上，访问主机的这些端口就相当于访问容器的对应端口，不应该映射过多个端口，否则容器的启动会非常慢。
* ```--name myWork```：指定容器的名称为myWork，你可以自行设置容器名称。
* ```course:v1```：创建容器用的镜像，这个镜像是之前通过```docker import```导入的镜像。
* ```bash```：在容器中运行的具体命令，这个bash命令代表运行命令行。

#### 4.3.2 Linux系统

​       对于Linux系统，运行如下命令以创建docker容器：

<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-itd<span class="w"> </span>--name<span class="w"> </span>myWork<span class="w"> </span>--net<span class="o">=</span>bridge<span class="w"> </span>course:v1<span class="w"> </span>bash
</code></pre></div>

​       其中```docker run```代表创建并运行容器，其它参数说明如下：

* ```-itd```：-i 交互式操作；-t 在终端运行命令；-d在后台运行。
* ```--name myWork```：指定容器的名称为myWork，你可以自行设置容器名称。
* ```--net=bridge```：指定容器的网络模式为bridge桥接模式，这样子系统会给每个容器分配一个内部ip地址，可以直接通过ip地址访问该容器。实际上不需要指定该选项，因为bridge是docker创建时候的默认网络选项。
* ```bash```：在容器中运行的具体命令，这个bash命令代表运行命令行。

​       此种情况下，连接上（如何进入容器命令行请参考4.4章节）容器以后，在**容器内**部执行```ip address```命令，会显示如下内容：

![](../img/pictures/截屏2021-02-07 15.39.32.png)

​       其中**eh0**选项中的**172.18.0.2**即系统分配给容器的ip地址，在**系统中**（**非容器中**）ping该地址，是可以有反应的，如下图：

<img src="../img/pictures/截屏2021-02-07 15.41.22.png" style="zoom:50%;" />

​       这个内部ip地址<font color=red>**非常重要**</font>，以后很多地方（如远程连接数据库，配置nginx端口转发等）都会用到这个内部ip地址。

​        这里解释一下为什么在**Linux**系统中可以使用桥接模式而在**Mac**和**Windows**系统中需要使用端口映射的模式，这是因为**Mac**和**Windows**下的**Docker**实际运行在一个**Docker**自己开发的**Linux**虚拟机上，而**Linux**下的**Docker**则直接运行在系统上。使用桥接模式运行**Docker**容器，意味着运行容器的系统可以通过内部ip访问**Docker**容器，但是这个运行容器的系统对**Mac**和**Windows**而言是内部的虚拟机，其无法直接和**Mac**、**Windows**系统进行交互，所以在**Mac**和**Windows**系统上采用主机模式运行**Docker**是没有任何意义的，只能通过端口映射的方式来与系统交互。

#### 4.3.3 关闭和启动容器

​        在创建容器后运行```docker ps```命令就可以看到所有正在运行的容器，```docker ps -a```则可以看到所有的容器（包括关闭的容器）。

​       关闭容器的命令为

<div class="highlight"><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>docker<span class="w"> </span>stop<span class="w"> </span>myWork
</code></pre></div>

​       重启容器的命令为

<div class="highlight"><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>docker<span class="w"> </span>start<span class="w"> </span>myWork
</code></pre></div>

​       注意重启容器不是```docker run```，```docker run```会创建一个全新的容器，该新容器与旧容器数据完全隔离！

### 4.4 启动Redis和Mongodb

​       在创建完成容器以后，通过执行

<div class="highlight"><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>docker<span class="w"> </span><span class="nb">exec</span><span class="w"> </span>-it<span class="w"> </span>myWork<span class="w"> </span>bash
</code></pre></div>

​       命令连接容器的终端，通过终端对容器的内部进行操作。在运行完成该命令后，此时已经进入了容器的终端。通过```ps -aux```命令可以判断目前是否在容器中，这个命令可以展示目前所有正在运行的进程，容器中的进程一般很少且PID编号较小，而**Linux**系统本身会有很多个进程，且很多进程的PID编号较大，如下图为一个容器运行```ps -aux```命令展示的进程列表：

<img src="../img/pictures/截屏2021-02-07 09.12.26.png" style="zoom:50%;" />

​       可以看到容器中目前只有五个进程在运行，其中两个进程是bash命令行进程，一个进程是```ps -aux```进程本身，剩下两个进程就是在容器中启动的**MongoDB**和**Redis**进程。之所以容器中的进程这么少是因为容器的依赖进程都已经在运行容器的系统（对于**Mac**和**Window**而言是虚拟机）上存在，容器不需要再创建这些进程，容器所做的只是将容器本身的环境与系统环境隔离开来而已。     

​       容器中启动MongoDB的命令是：

<div class="highlight"><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a>mongod<span class="w"> </span>--config<span class="w"> </span>/etc/mongodb.conf<span class="w"> </span><span class="p">&amp;</span>
</code></pre></div>

​       容器中启动Redis的命令是：

<div class="highlight"><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>redis-server<span class="w"> </span>/etc/redis/redis.conf
</code></pre></div>

​       此时运行```ps -aux```可以看到**MongoDB**和**Redis**的进程信息。可以下载[MongoDB Compass](https://www.mongodb.com/try/download/compass)和[Another Redis Desktop Manager](https://github.com/qishibo/AnotherRedisDesktopManager)来对MongoDB和Redis进行可视化操作。**Redis**可以使用默认配置直接连接不需要密码，本地连接**MongoDB**的配置如下图：

<img src="../img/pictures/截屏2021-02-06 21.45.34.png" style="zoom:50%;" />

​       其中密码为```course2021```。

​       远程连接**Linux系统**上的**MongoDB**和**Redis**都需要通过**SSH隧道**连接，且需要把**Hostname**从**localhost**改成容器的**内部ip地址**如**172.18.0.2**，如下图为使用[Another Redis Desktop Manager](https://github.com/qishibo/AnotherRedisDesktopManager)远程连接**Linux**服务器上容器（内部IP为**172.18.0.2**）中的Redis数据库连接配置示例：

<img src="../img/pictures/截屏2021-02-22 15.27.28.png" style="zoom:70%;" />

​       其中SSH隧道的host就是服务器公网IP，Username和Password就是服务器用户和密码。

### 4.5 启动Java服务器

#### 4.5.1 Mac和Windows系统

​       首先需要通过```git clone```下载源码：

<div class="highlight"><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/xuwm14/dragon.git
</code></pre></div>

​       一般而言，同学们使用**Mac**和**Windows**系统只是为了在本地调试服务器。在调试前需要同学们在系统上安装**Maven**。

​       在安装好**Maven**以后，直接通过**IntelliJ IDEA**打开项目源码，然后右键点击**pom.xml**->**Maven**->**Reimport**，则**Maven**会自动下载项目所需的全部**Java依赖包**，在下载好之后就可以直接运行或者调试应用了，**IntelliJ IDEA**会自动识别出启动类**com.flying.dragon.DragonApplication**，如果没有识别出来请自己指定。

<img src="../img/pictures/截屏2021-02-06 21.57.17.png" style="zoom:50%;" />

​       运行成功后在浏览器输入http://localhost:8080/user/login则可以获取到如下内容：

![](../img/pictures/访问结果.png)

​       注意这种情况下，使用的**MongoDB**和**Redis**是运行在**docker**容器中的，容器停止运行会导致无法连接到**MongoDB**和**Redis**。但是**Java**服务器是运行在自己电脑上的。

#### 4.5.2 Linux系统

​       将**Java**源码上传到**Linux服务器**上，上传方式请自行选择。

​       然后在**系统中**（**非容器中**）运行如下命令将**Java**源码拷贝到**docker**容器中：

<div class="highlight"><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>docker<span class="w"> </span>cp<span class="w"> </span>/path/filename<span class="w"> </span>容器id或名称:/path/filename
</code></pre></div>

​       或者也可以在容器中通过```git clone```直接下载源码：

<div class="highlight"><pre><span></span><code><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/xuwm14/dragon.git
</code></pre></div>

​       进入容器的源码主目录下（即包含**pom.xml**的目录），运行

<div class="highlight"><pre><span></span><code><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a>mvn<span class="w"> </span>install
</code></pre></div>

​       此时容器会通过**maven**自动下载项目依赖的所有**jar**包，第一次运行需要下载很多依赖包，时间比较漫长，请耐心等待容器下载完成，在依赖包下载完成后还会自动将项目打包成**jar**包。打包完成的**jar**包存储在**target**目录中，名称为**dragon-0.0.1.jar**，以后代码有修改时需要重新打包也可以运行此命令。

​       此时进入**jar**包所在目录执行

<div class="highlight"><pre><span></span><code><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a>nohup<span class="w"> </span>java<span class="w"> </span>-jar<span class="w"> </span>dragon-0.0.1.jar<span class="w"> </span><span class="p">&amp;</span>
</code></pre></div>

​       则服务器会在后台启动，在这种情况下，**MongoDB**、**Redis**和**java**应用程序都是运行在容器之中的，在**Linux系统（非容器中）**中输入

<div class="highlight"><pre><span></span><code><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a>curl<span class="w"> </span>http://172.18.0.2:8080/user/login
</code></pre></div>

​       其中的```172.18.0.2```请自行替换为自己容器的内部ip，返回如下信息说明服务器启动成功（注意启动需要一定的时间，具体进程可以查看**nohup.out**）：

![](../img/pictures/访问结果3.png)

​       可以在**容器**的**warn**日志文件中查看更多内容，日志文件目录为**容器**中**jar**包文件同级目录**logs**。但是此时的服务只可以在内部访问，因为```172.18.0.2```这是个内部ip地址，外部无法访问。这时候就需要利用到了**nginx**的转发功能。

​       在**系统中**（**非容器中**）下载好**nginx**，配置如下：

<div class="highlight"><pre><span></span><code><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a><span class="k">server{</span>
<a id="__codelineno-14-2" name="__codelineno-14-2" href="#__codelineno-14-2"></a><span class="w">  </span><span class="s">listen</span><span class="w"> </span><span class="mi">8000</span><span class="p">;</span><span class="w">  </span><span class="c1"># 监听的端口</span>
<a id="__codelineno-14-3" name="__codelineno-14-3" href="#__codelineno-14-3"></a>
<a id="__codelineno-14-4" name="__codelineno-14-4" href="#__codelineno-14-4"></a><span class="w">  </span><span class="k">location</span><span class="w"> </span><span class="s">/</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-14-5" name="__codelineno-14-5" href="#__codelineno-14-5"></a><span class="w">    </span><span class="kn">proxy_pass</span><span class="w">  </span><span class="s">http://172.18.0.2:8080</span><span class="p">;</span><span class="w"> </span><span class="c1"># 转发规则</span>
<a id="__codelineno-14-6" name="__codelineno-14-6" href="#__codelineno-14-6"></a><span class="w">    </span><span class="kn">proxy_set_header</span><span class="w"> </span><span class="s">Host</span><span class="w"> </span><span class="nv">$proxy_host</span><span class="p">;</span><span class="w"> </span><span class="c1"># 修改转发请求头，让端口的应用可以受到真实的请求</span>
<a id="__codelineno-14-7" name="__codelineno-14-7" href="#__codelineno-14-7"></a><span class="w">    </span><span class="kn">proxy_set_header</span><span class="w"> </span><span class="s">X-Real-IP</span><span class="w"> </span><span class="nv">$remote_addr</span><span class="p">;</span>
<a id="__codelineno-14-8" name="__codelineno-14-8" href="#__codelineno-14-8"></a><span class="w">    </span><span class="kn">proxy_set_header</span><span class="w"> </span><span class="s">X-Forwarded-For</span><span class="w"> </span><span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
<a id="__codelineno-14-9" name="__codelineno-14-9" href="#__codelineno-14-9"></a><span class="w">  </span><span class="p">}</span>
<a id="__codelineno-14-10" name="__codelineno-14-10" href="#__codelineno-14-10"></a><span class="k">}</span>
</code></pre></div>

​       启动**nginx**则会自动将**8000**端口的请求转发到容器**172.18.0.2**的**8080**端口，就可以在外部访问了。访问结果如下（需要服务器对外开放**8000**端口）：

<img src="../img/pictures/访问结果4.png" style="zoom:50%;" />

### 4.6 运行测试业务

​       为了方便大家判断自己环境是否配置正常，助教在框架中封装了一系列测试任务，如下图：

<img src="../img/pictures/测试业务.png" style="zoom:50%;" />

​       如果所有的测试任务都可以正常执行，说明你的程序环境是完全没有问题的。至于怎么运行测试任务，请同学们仔细阅读框架代码，然后就会明白了。

​       测试任务运行正常以后，同学们就可以在框架上开始自己的后台开发之旅了！



## 五、课程共用服务器访问指南

在大作业布置的同时，我们会为同学们提供课程共用的服务器，介时会为同学提供服务器的访问指南。

 ​      为了方便同学们进行后端编程，课程给同学们提供了免费的公用服务器，该服务器的ip地址是```8.140.133.34```，在小组组建完成以后，助教会给每个小组一个用户名和密码，同学们可以使用该用户名和密码登录到公用服务上，然后根据助教之前的教程，使用docker创建自己的容器，在自己的容器内进行开发，在开发完成后使用nginx将容器端口映射到真实的服务器端口上就可以在外部进行访问了。

​       助教已经将课程的基础镜像导入到共用服务器中，同学们在服务器上运行

<div class="highlight"><pre><span></span><code><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a>docker<span class="w"> </span>images
</code></pre></div>

​       命令就可以看到助教提前导入的镜像，运行

<div class="highlight"><pre><span></span><code><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a>docker<span class="w"> </span>ps<span class="w"> </span>-a
</code></pre></div>

​       命令可以看到所有的容器，如果不加参数-a则会展示所有正在运行中的容器，助教已经在服务器上创建了myWork容器。

​       nginx配置文件全都存储在```/etc/nginx/sites-enabled```目录下面，里面有助教提供的示例配置文件example，同学们可以仿照该示例配置文件新建自己的配置文件，将容器端口映射到服务器上。在修改好自己的配置后，运行

<div class="highlight"><pre><span></span><code><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a>nginx<span class="w"> </span>-s<span class="w"> </span>reload
</code></pre></div>

​       命令就可以让端口映射生效了。

​       后台框架源码存放在目录```/course/code```下，导出的docker镜像存放在``/course/course.tar``中，已经将该镜像导入到docker中，同学们无须重复导入！

​       为了保证同学们彼此之间的开发不会产生冲突，每个小组的docker容器会分配唯一的名称，同时会给每个小组分配几个固定的端口号和nginx配置名称，请小组同学在开发时使用自己的名称创建docker容器，并在配置nginx时只使用属于自己小组的端口号，<font color="red">任何不符合规范的容器或者nginx配置都可能会被删除而没有事先通知！</font> -->





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.e5c33ebb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.51d95adb.min.js"></script>
      
    
  </body>
</html>